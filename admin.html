
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notenkonferenz – Admin</title>
  <meta name="robots" content="noindex,nofollow" />
  <style>
    body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin:0; padding:20px; background:#0b1020; color:#eaf2ff; }
    .box { background:#151a31; padding:20px; border-radius:12px; max-width:720px; margin:auto; }
    textarea, input { width:100%; padding:10px; border-radius:8px; background:#0f1428; color:#eaf2ff; border:1px solid #2a335f; }
    textarea { height:220px; }
    button { padding:10px 16px; border:0; border-radius:8px; cursor:pointer; font-size:16px; }
    .btn-primary { background:#3b82f6; color:white; }
    .btn-green   { background:#22c55e; color:white; }
    .btn-red     { background:#ef4444; color:white; }
    .row { display:flex; gap:8px; align-items:center; }
    .row-space { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .label { font-weight:600; margin-top:12px; display:block; }
    .muted { opacity:.75; font-size:13px; }
    .error { color:#ffb4b4; margin-top:8px; }
  </style>
</head>
<body>

<div class="box">
  <h2>Admin – Notenkonferenz</h2>

  <!-- Login -->
  <div id="loginBox">
    <label class="label">E‑Mail</label>
    <input id="email" type="email" autocomplete="username" />

    <label class="label">Passwort</label>
    <input id="passwort" type="password" autocomplete="current-password" />

    <div class="row">
      <button id="loginBtn" class="btn-primary">Anmelden</button>
    </div>
    <div id="loginError" class="error"></div>
    <div class="muted" style="margin-top:6px;">Für GitHub Pages muss die Domain <code>chrisiweb.github.io</code> unter <i>Authentifizierung → Einstellungen → Autorisierte Domains</i> freigegeben sein.</div>
  </div>

  <!-- Panel -->
  <div id="panel" style="display:none;">
    <label class="label">Liste aller Klassen (eine pro Zeile)</label>
    <textarea id="klassenInput" placeholder="z. B.&#10;1A&#10;1B&#10;1C&#10;2A&#10;…"></textarea>

    <!-- Buttonzeile: links der Start/Nächste-Button; rechts der Zurück-Button -->
    <div class="row-space" style="margin-top:10px;">
      <div class="row">
        <button id="startNextBtn" class="btn-primary" title="Startet mit den ersten zwei Klassen; danach immer &quot;Nächste Klasse&quot;">Start</button>
        <button id="speichernListeBtn" class="btn-green" title="Nur Liste speichern (ohne Vor-/Aktuellenwechsel)">Liste speichern</button>
      </div>
      <button id="prevBtn" class="btn-red" title="Geht einen Schritt zurück (Vorbereitung → Aktuell; davorige Klasse → Vorbereitung)">Zurück</button>
    </div>

    <div id="info" class="muted" style="margin-top:10px;"></div>
  </div>
</div>

<script type="module">
  // --- Deine Firebase Config ---
  const firebaseConfig = {
    apiKey: "AIzaSyCuLVnVCnpc1JPO5eRsUpwOdTjacZ6cgso",
    authDomain: "gvp-notenkonferenz.firebaseapp.com",
    databaseURL: "https://gvp-notenkonferenz-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "gvp-notenkonferenz",
    storageBucket: "gvp-notenkonferenz.appspot.com",
    messagingSenderId: "443453428623",
    appId: "1:443453428623:web:3d3640bfe6ed2c38e871fa",
    measurementId: "G-SVZX9DEJNP"
  };

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getDatabase(app);

  const loginBox = document.getElementById("loginBox");
  const panel    = document.getElementById("panel");
  const info     = document.getElementById("info");

  const startNextBtn      = document.getElementById("startNextBtn");
  const speichernListeBtn = document.getElementById("speichernListeBtn");
  const prevBtn           = document.getElementById("prevBtn");
  const klassenInput      = document.getElementById("klassenInput");

  // interner Zustand
  let klassen = [];   // Array der Klassen
  let pos = 0;        // Index der "Aktuell" Klasse in klassen

  // --- Login ---
  document.getElementById("loginBtn").onclick = async () => {
    const email = (document.getElementById("email").value || "").trim();
    const pass  = (document.getElementById("passwort").value || "").trim();
    document.getElementById("loginError").textContent = "";
    try {
      await signInWithEmailAndPassword(auth, email, pass);
    } catch (err) {
      document.getElementById("loginError").textContent = err?.message ?? String(err);
    }
  };

  onAuthStateChanged(auth, async (user) => {
    const signedIn = !!user;
    loginBox.style.display = signedIn ? "none" : "";
    panel.style.display    = signedIn ? "" : "none";
    if (!signedIn) return;

    // Beim Anmelden: gespeicherte Liste und Position laden
    await ladeSteuerung();
    // Button-Beschriftung abhängig davon, ob wir noch am Anfang sind
    aktualisiereStartNextLabel();
    // Texteingabe mit gespeicherter Liste füllen
    klassenInput.value = klassen.join("\n");
    zeigeInfo();
  });

  // --- Daten laden/speichern (Persistenz) ---
  async function ladeSteuerung() {
    // Struktur in DB: steuerung: { liste: [..], pos: 0 }
    const snap = await get(ref(db, "steuerung"));
    const v = snap.exists() ? snap.val() : {};
    klassen = Array.isArray(v.liste) ? v.liste : [];
    pos     = Number.isInteger(v.pos) ? v.pos : 0;
    // Grenzen sichern
    if (pos < 0) pos = 0;
    if (pos >= Math.max(klassen.length, 1)) pos = Math.max(klassen.length - 1, 0);
  }

  async function speichereSteuerung() {
    await set(ref(db, "steuerung"), { liste: klassen, pos });
  }

  async function schreibeAnzeige() {
    const aktuell = klassen[pos] || "";
    const vorb    = klassen[pos + 1] || "";
    await update(ref(db, "anzeige"), {
      aktuell,
      vorbereitung: vorb,
      aktualisiertAm: Date.now()
    });
  }

  function zeigeInfo() {
    const aktuell = klassen[pos] || "—";
    const vorb    = klassen[pos + 1] || "—";
    info.innerHTML = `
      <div>Aktuell: <b>${aktuell}</b></div>
      <div>In Vorbereitung: <b>${vorb}</b></div>
      <div>Position: ${klassen.length ? (pos + 1) : 0} / ${klassen.length}</div>
    `;
  }

  function aktualisiereStartNextLabel() {
    // "Start" nur dann, wenn pos==0 und Anzeige noch nicht initial gesetzt wurde
    // Praktisch: Wenn keine Daten in "anzeige" sind oder pos==0 -> "Start"
    startNextBtn.textContent = (pos === 0 ? "Start" : "Nächste Klasse");
  }

  // --- Bedienlogik ---
  speichernListeBtn.onclick = async () => {
    // Liste aus Text übernehmen, pos belassen
    klassen = klassenInput.value
      .split("\n")
      .map(x => x.trim())
      .filter(x => x.length > 0);
    // pos validieren (falls Liste kürzer wurde)
    if (pos >= klassen.length) pos = Math.max(klassen.length - 1, 0);
    await speichereSteuerung();
    await schreibeAnzeige();   // Anzeige auf aktuelle pos/liste synchronisieren
    aktualisiereStartNextLabel();
    zeigeInfo();
  };

  startNextBtn.onclick = async () => {
    // Wenn Liste leer → nichts tun
    if (klassen.length === 0) {
      alert("Bitte zuerst die Klassenliste eingeben (eine Klasse pro Zeile) und speichern/Start drücken.");
      return;
    }
    // Falls wir am Start sind (pos==0 und Anzeige evtl. leer), setzen wir einfach die ersten beiden
    // Danach: pos um 1 erhöhen = "Nächste Klasse"
    if (pos < klassen.length - 1) {
      // Beim ersten Klick mit pos==0 setzen wir einfach – danach immer weiter
      if (startNextBtn.textContent === "Start") {
        // nicht erhöhen; nur initiale Anzeige setzen
      } else {
        pos++;
      }
    } else {
      // am Ende der Liste bleibt Vorbereitung leer
      if (startNextBtn.textContent !== "Start") {
        // pos bleibt auf letztem Element
      }
    }
    await speichereSteuerung();
    await schreibeAnzeige();
    aktualisiereStartNextLabel();
    zeigeInfo();
    // Nach dem ersten Klick immer "Nächste Klasse"
    startNextBtn.textContent = "Nächste Klasse";
  };

  prevBtn.onclick = async () => {
    if (klassen.length === 0) return;
    // Ein Schritt zurück: pos-1 (mind. 0)
    if (pos > 0) pos--;
    await speichereSteuerung();
    await schreibeAnzeige();
    aktualisiereStartNextLabel();
    zeigeInfo();
  };
</script>

</body>
</html>
